# Varfuri Triunghi - MODERN

**_01_02_varfuri_triunghi.cpp_**

Program ce deseneaza 3 puncte colorate diferit care reprezinta
varfurile unui triunghi, folosidu-se tehnicile MODERN OpenGL

## 2. VarfuriTriunghi
VarfuriTriunghi este clasa in care vom retine informatiile si
codul necesar pentru a desena 3 puncte colorate diferit.

> Pentru explicatii mai detaliate, cititi: _Template -> Square_.

```cpp
class VarfuriTriunghi
{
    GLuint vaoId, vboId, colorBufferId;
    
    GLfloat vertices[3 * 4] = {
        -0.8f, -0.8f, 0.0f, 1.0f,
         0.0f,  0.8f, 0.0f, 1.0f,
         0.8f, -0.8f, 0.0f, 1.0f,
    };

    GLfloat colors[3 * 4] = {
        1.0f, 0.0f, 0.0f, 1.0f,
        0.0f, 1.0f, 0.0f, 1.0f,
        0.0f, 0.0f, 1.0f, 1.0f,
    };
```
Am definit:
- variabilele ce vor retine id-urile pentru VAO, VBO-ul pentru 
coordonatele varfurilor si VBO-ul pentru culorile varfurilor
- coordonatele varfurilor
- culorile varfurilor

```cpp
public:
    VarfuriTriunghi()
    {
        glGenVertexArrays(1, &vaoId);
        glBindVertexArray(vaoId);
	
        glGenBuffers(1, &vboId);
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

        glGenBuffers(1, &colorBufferId);
        glBindBuffer(GL_ARRAY_BUFFER, colorBufferId);
        glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);

        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);
    }
```
Am implementat constructor-ul, in care:
- am initializat VAO
- am initializat VBO-ul pentru coordonatele varfurilor si am incarcat coordonatele
- am definit atributul de la ```location = 0``` din shader-ul de varfuri pentru 
a putea accesa coordonatele varfurilor
- am initializat VBO-ul pentru culorile varfurilor si am incarcat culorile
- am definit atributul de la ```location = 1``` din shader-ul de varfuri pentru
  a putea accesa culorile varfurilor

```cpp
    void render() const
    {
        glPointSize(20.0);               
        glDrawArrays(GL_POINTS, 0, 3);
 
    }
```
Am setat dimensiunea unui varf la 20 de pixeli si am inceput sa desenez
varfurile, in modul GL_POINTS, incepand cu cel de la ```index=0``` si desenand
```count=3``` varfuri.

```cpp
    ~VarfuriTriunghi()
    {
        glDisableVertexAttribArray(1);
        glDisableVertexAttribArray(0);

        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glDeleteBuffers(1, &colorBufferId);
        glDeleteBuffers(1, &vboId);

        glBindVertexArray(0);
        glDeleteVertexArrays(1, &vaoId);
    }
```
Am implementat destructorul in care am dezactivat si sters buffere-le create
pentru acest obiect.

## 2. Shadere
Vom folosi metoda **inline** de incarcare a Shader-elor, scriind codul
pentru acestea ca siruri de caractere in programul principal.

```cpp
GLuint
  VertexShaderId,
  FragmentShaderId,
  ProgramId;
```
Definim variabile pentru a retine identificatorii pentru:
- shader-ul de varfuri (cel care afecteaza geometria scenei)
- shader-ul de fragment (cel care afecteaza culoarea pixelilor)
- obiectul program (un obiect caruia i se pot atasa shadere)


```cpp
const GLchar* VertexShader =
{
      "#version 400\n"\

      "layout(location=0) in vec4 in_Position;\n"\
      "layout(location=1) in vec4 in_Color;\n"\
      "out vec4 ex_Color;\n"\

      "void main(void)\n"\
      "{\n"\
      "  gl_Position = in_Position;\n"\
      "  ex_Color = in_Color;\n"\
      "}\n"
};
```
Retinem codul pentru shader-ul de varfuri ca un sir de caractere.

Am inceput prin a seta versiunea pentru GLSL si prin a defini atributele
pentru a corespunde cu cele din momentul crearii VBO-urilor pentru 
coordnatele si culorile varfurilor (atentie la tipul folosit ```vec4``` care
trebuie sa corespunda cu datele pe care le-am transmis)

Am creat variabila ```ex_Color``` si am utilizat keyword-ul ```out``` pentru a o
transmite catre shader-ul de fragment.

Variabile ```gl_Position``` este cea care primeste coordonatele varfului, 
iar ```ex_Color``` (definita de noi), culoarea acestuia.


```cpp
const GLchar* FragmentShader =
{
    "#version 400\n"\
    
    "in vec4 ex_Color;\n"\
    "out vec4 out_Color;\n"\
    
    "void main(void)\n"\
    "{\n"\
    "  out_Color = ex_Color;\n"\
    "}\n"
};
```
In mod similar, retinem codul pentru shader-ul de fragment ca un sir de caractere.

Am setat versiunea pentru GLSL, dupa care am definit ```ex_Color```, 
avand keyword-ul ```in```, pentru a primit culoarea de la shader-ul de varfuri,
si ```out_Color```, avand keyword-ul ```out```, pentru a transmite culoarea mai departe.

In functia main, am copiat culoarea primita de la shader-ul de varfuri in variabila
ca ve fi transmisa mai departe.

```cpp
void CreateShaders() {
    VertexShaderId = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(VertexShaderId, 1, &VertexShader, NULL);
    glCompileShader(VertexShaderId);

    FragmentShaderId = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(FragmentShaderId, 1, &FragmentShader, NULL);
    glCompileShader(FragmentShaderId);

    ProgramId = glCreateProgram();
    glAttachShader(ProgramId, VertexShaderId);
    glAttachShader(ProgramId, FragmentShaderId);
    glLinkProgram(ProgramId);
    glUseProgram(ProgramId);
}
```
Functia ```CreateShaders()``` o vom folosi in momentul in care rulam programul
pentru a initializa cele doua shadere si pentru a le atasa programului.

Incepem prin a apela ```glCreateShader(GL_VERTEX_SHADER)``` ce creeaza un nou shader,
identificat prin ```VertexShaderId```. Cu ajutorul functiei ```glShaderSource```, 
am setat codul sursa pentru shader ca fiind cel definit mai devreme in ```VertexShader```, 
dupa care am compilat shader-ul.

In mod similar procedam si pentru shader-ul de fragmente. Atentie la tipul folosit
in momentul apelarii functiei ```glCreateShader```

In final, cream un obiect program, caruia ii atasam cele doua shadere, dupa care
il atasam programului nostru principal si incepem sa il folosim.


```cpp
void DestroyShaders() {  
    glUseProgram(0);

    glDetachShader(ProgramId, VertexShaderId);
    glDetachShader(ProgramId, FragmentShaderId);

    glDeleteShader(FragmentShaderId);
    glDeleteShader(VertexShaderId);

    glDeleteProgram(ProgramId);
}
```

Functia ```DestroyShader()``` o vom folosi la finalul executiei, cand
vrem sa stergem shader-ele si obiectele create.

Incepem prin a detasa cele doua shadere de la obiectul program, dupa care
stergem shader-ele si obiectul program.

# 3. Initializare si Randare
```cpp
VarfuriTriunghi* varfuriTriunghi = nullptr;
```

Definim un pointer catre obiectul de tip ```VarfuriTriunghi```, pe care 
urmeaza sa-l initializam in ```main()``` sa utilizam metoda pentru randare
implementat anterior.

```cpp
void RenderFunction()
{
    glClear(GL_COLOR_BUFFER_BIT); 
    varfuriTriunghi->render();
    glFlush();
}
```
Am implementat functia principala de randare, in care:
- curatam ecranul
- desenam obiectul ```varfuriTriunghi```
- afisam modificarile pe ecran

```cpp
int main(int argc, char* argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);           
    glutInitWindowPosition(100, 100);                      
    glutInitWindowSize(700, 500);                          
    glutCreateWindow("Varfuri triunghi - OpenGL <<nou>>"); 
    
    glewInit();
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); 

    varfuriTriunghi = new VarfuriTriunghi();

    CreateShaders();                    
    glutDisplayFunc(RenderFunction);    
    glutCloseFunc(DestroyShaders);      
    
    glutMainLoop();

    delete varfuriTriunghi;
    
    return 0;
}
```
> Pentru explicatii mai detaliate, cititi _Template -> Initializare si Randare_

In functia ```main()```:
- am initializat glut
- am initializat fereastra
- am initializat glew
- am setat culoarea de fundal
- am initializat obiectul ```varfuriTriunghi```
- am creat shadere-ele
- am setat functia de randare
- am inceput randarea
- dupa finalizare, am sters obiectele create