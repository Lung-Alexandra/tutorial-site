# Animatie - Dreptunghi cu satelir

_**03_02_animatie.cpp**_

Program ce deseneaza un dreptunghi ce se deplaseaza stanga-dreapta si are un patrat ce orbiteaza
in jurul sau, folosindu-se tehnicile MODERN OpenGL.

ELEMENTE DE NOUTATE:
- transformari si compunerea acestora folosind biblioteca glm
- functii pentru utilizarea mouse-ului

# 1. Shader-ul de varfuri
```cpp
#version 330 core

layout (location = 0) in vec4 in_Position;   
layout (location = 1) in vec4 in_Color;      

// out vec4 gl_Position;
out vec4 ex_Color;     

uniform mat4 projectionMatrix;
uniform mat4 modelMatrix;

void main(void)
{
    gl_Position = projectionMatrix * modelMatrix * in_Position;
    ex_Color = in_Color;
} 
```
In shader-ul de varfuri am utilizat doua matrici:
- **projectionMatrix** (matrice de proiectie, una pentru tot programul)
- **modelMatrix** (matrice model, pentru fiecare obiect, si reprezeinta compunerea 
transformarilor aplicate asupra obiectului)

pentru a modifica pozitia varfurilor in timpul animatiei.

## 2. Clasa Axis
Aceasta clasa are rolul de a desena in scena o linie orizontala si o linie verticala reprezentand 
axele OX si OY.

Relevanta este metoda ```render()```:
```cpp
	void render(const Shader* shader) const
	{
		glBindVertexArray(vaoId);
		
		shader->setMat4("modelMatrix", glm::mat4(1.0f));
		shader->setInt("colorCode", 0);
		glDrawArrays(GL_LINES, 0, 4);
	}
```
A se observa ca am setat **matricea model** ca fiind egala cu **matricea identitate**
(deoarece nu am aplicat transformati asupra axelor).

Nu am setat **matricea de proiectie**, deoarece ea este comuna tuturor obiectelor si urmeaza 
sa fie setata in functia principala de desenare ```RenderFunction()```

## 3. Clasa DreptunghiCuSatelit

```cpp
class DreptunghiCuSatelit
{
	GLuint vaoId, vboId;
	GLfloat vertices[4 * 4] = {
		-50.0f,  -50.0f, 0.0f, 1.0f,
		50.0f, -50.0f, 0.0f, 1.0f,
		50.0f,  50.0f, 0.0f, 1.0f,
		-50.0f,  50.0f, 0.0f, 1.0f,
	};

	float xPosition = 0.0, direction = 0.0, positionStep=0.3, angleStep = 0.0002, angle = 0;
```

Pe langa pozitiile varfurilor si id-uri pentru VAO si VBO, ```DreptunghiCuSatelit```
contine atribute pentru a stoca:
- pozitia pe axa orizontala ```xPosition```
- unghiul de rotatie al obiectului care orbiteaza ```angle```
- directia animatiei ```direction```


### 3.1 render()
```cpp
	void render(const Shader* shader) const
	{
		glBindVertexArray(vaoId);

		glm::mat4 translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(xPosition, 0.0, 0.0));
		glm::mat4 scaleMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(1.1, 0.3, 0.0));

		glm::mat4 modelMatrix = translationMatrix * scaleMatrix;
		shader->setMat4("modelMatrix", modelMatrix);
		shader->setInt("colorCode", 1);
		glDrawArrays(GL_POLYGON, 0, 4);
```
Aceasta prima parte a functiei ```render()``` se ocupa de desenarea dreptunghiului.

Pentru ca obiectul din scena sa corespunda cu atributele definite (pozitie, dimensiune, rotatie)
am definit ```translationMatrix``` si ```rotationMatrix```, acestea fiind transformarile
aplicate asupra dreptunghiului. Dupa aceea, le inmultim (atentie la ordine) pentru
a calcula ```modelMatrix```, ce va fi transmisa carte shader.

```cpp
		glm::mat4 scaleMatrix2 =  glm::scale(glm::mat4(1.0f), glm::vec3(0.25, 0.25, 0.0));
		glm::mat4 relativeTranslationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0, 80.0, 0.0));
		glm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0, 0, 1));
		modelMatrix = translationMatrix * rotationMatrix * relativeTranslationMatrix * scaleMatrix2;
		shader->setMat4("modelMatrix", modelMatrix);
		shader->setInt("colorCode", 2);
		glDrawArrays(GL_POLYGON, 0, 4);
	}
```
Ultima parte a functiei ```render()``` are rolul de a desena obiectul care orbiteaza.

Asupra acestuia se aplica mai multe transformari:
- ```scaleMatrix2```: pentru a scala obiectul la dimensiunile dorite
- ```relativeTranslationMatrix```: translatia fata de dreptunghi
- ```rotationMatrix```: rotatia in jurul dreptunghiului
- translationMatrix, calculata anterior.

Similar, calculam ```modelMatrix``` inmultind matricile in ordinea corecta (din punct de vedere logic, 
transformarile se aplica in ordinea: scalare, translatie fata de dreptunghi, rotatie, translatie pe axa orizontala)

### 3.2 update()
Functia aceasta are rolul de a actualiza pozitia si unghiul obiectelor.

Va fi apelata in ```IdleFunction()```, pentru a actualiza continuu animatia.

### 3.3 goLeft() & goRight()
Functii ce seteaza sensul animatiei.

Vor fi folosite in ```MouseFunction()``` pentru a asigura interactiunea cu mouse-ul.