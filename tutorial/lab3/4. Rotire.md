# Rotatia unui dreptunghi in jurul propriului centru

_**03_04_rotire.cpp**_

Program care utilizeaza compunerea transformarilor si rotatia cu un centru diferit de origine.
Se vor desena un patrat si rotatia sa, folosindu-se tehnicile MODERN OpenGL;

## Dreptunghi::render()
```cpp
void render(const Shader* shader) const
{
    glBindVertexArray(vaoId);
    
    shader->setMat4("modelMatrix", glm::mat4(1.0f));
    shader->setInt("colorCode", 1);
    glDrawArrays(GL_POLYGON, 0, 4);
```
Prima parte a metodei ```render()``` deseneaza in mod obisnuit un dreptunghi. Deoarece
nu vrem sa aplicam nicio transformare asupra obiectului, am setat ```modelMatrix``` la
matricea identitate.

```cpp
    glm::mat4 translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(-100.f, -100.f, 0.0));
    glm::mat4 translationMatrixInverse = glm::translate(glm::mat4(1.0f), glm::vec3(100.f, 100.f, 0.0));
    GLfloat angle = 3.1415 / 8; 
    glm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0.0, 0.0, 1.0));

    glm::mat4 modelMatrix = translationMatrixInverse * rotationMatrix * translationMatrix;
    shader->setMat4("modelMatrix", modelMatrix);
    shader->setInt("colorCode", 2);
    glLineWidth(4.0);
    glDrawArrays(GL_LINE_LOOP, 0, 4);
}
```

Mai complicat este in cazul in care vrem sa rotim dreptunghiul in jurul propriului centru.
Daca incercam sa aplicam doar matricea de rotatie, atunci vom obtine un rezultat gresit, 
deoarece ```glm::rotate``` calculeaza matricea relativa la centrul scenei.

Pentru a efectua rotatia corect trebuie sa:
- translatam obiectul astfel incat centru de rotatie sa ajunga in originea scenei
- aplicat rotatia
- translatam obiectul inapoi in pozitia initiala (transformarea opusa primei translatii)
Astfel, matricea model va fi:

``` glm::mat4 modelMatrix = translationMatrixInverse * rotationMatrix * translationMatrix;```