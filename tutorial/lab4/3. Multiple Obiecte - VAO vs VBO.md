# Desenarea mai multor obiecte - VAO vs VBO

_**04_03a_doua_VAO.cpp**_

_**04_03b_doua_VBO.cpp**_

Cele doua fisiere demonstreaza cum se pot folosit VAO-uri si VBO-uri multiple pentru 
a stoca datele despre doua obiecte diferite ce urmeaza a fi demonstrate. Scopul acestui
exercitiu este intelegerea motivatiei pentru care folosim VAO si VBO si de ce este 
mai simplu sa folosim VAO-uri diferite pentru obiecte diferite.

In continuarea, vrem sa desenam un dreptunghi si un pentagon, fiecare avand propriile 
coordonate, culori si indici.

# 1. Varianta 1 - un VAO, mai multe VBO
Incepem prin a declara toate informatiile de care avem nevoie (id-uri, coordonate, culor, indici):

```cpp
class DreptunghiSiPentagon
{
	GLuint vaoId;
	GLuint vboId1, colorBufferId1, eboId1;
	GLuint vboId2, colorBufferId2, eboId2;
	
	GLfloat vertices1[4 * 4] = {
		-55.0f, -35.0f,  0.0f,  1.0f,
		-25.0f, -35.0f,  0.0f,  1.0f,
		-25.0f,  -5.0f,  0.0f,  1.0f,
		-55.0f,  -5.0f,  0.0f,  1.0f
	};

	GLfloat colors1[9 * 4] = {
		0.3f, 0.4f, 0.6f, 1.0f,
		0.3f, 0.4f, 0.8f, 1.0f,
		0.5f, 0.7f, 0.9f, 1.0f,
		0.7f, 0.7f, 0.9f, 1.0f
	};

	GLuint indices1[4] = {
		0, 1, 2, 3
	};

	GLfloat vertices2[5 * 4] = {
		30.0f, 40.0f,  0.0f,  1.0f,
		10.0f, 20.0f,  0.0f,  1.0f,
		15.0f, -5.0f,  0.0f,  1.0f,
		45.0f, -5.0f,  0.0f,  1.0f,
		50.0f, 20.0f,  0.0f,  1.0f
	};

	GLfloat colors2[5 * 4] = {
		0.5f, 0.5f, 0.5f, 1.0f,
		0.6f, 0.6f, 0.6f, 1.0f,
		0.7f, 0.7f, 0.7f, 1.0f,
		0.9f, 0.9f, 0.9f, 1.0f,
		0.7f, 0.7f, 0.7f, 1.0f
	};

	GLuint indices2[5] = {
		3, 4, 0, 1, 2
	};
```

Mai departe vom initializa VAO si VBO-urile la fel ca pana acum:
```cpp
    glGenVertexArrays(1, &vaoId);
    glBindVertexArray(vaoId);
```
```cpp
    glGenBuffers(1, &vboId1);
    glBindBuffer(GL_ARRAY_BUFFER, vboId1);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices1), vertices1, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &colorBufferId1);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId1);
    glBufferData(GL_ARRAY_BUFFER, sizeof(colors1), colors1, GL_STATIC_DRAW);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &eboId1);														
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId1);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices1), indices1, GL_STATIC_DRAW);
```
```cpp
    glGenBuffers(1, &vboId2);
    glBindBuffer(GL_ARRAY_BUFFER, vboId2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices2), vertices2, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &colorBufferId2);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(colors2), colors2, GL_STATIC_DRAW);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &eboId2);														
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId2);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices2), indices2, GL_STATIC_DRAW);
```
In acest moment, toate VBO-urile apartin aceluiasi VAO.

### Randare
Vom desena obiectele pe rand, asa ca inainte de a apela ```glDrawElements``` trbuie sa activam
toate bufferele specifice obiectului nostru si sa initializam lucrul cu atribute pentru
bufferele proaspat activate.
```cpp
void render() const
{
    glBindVertexArray(vaoId);
    
    glBindBuffer(GL_ARRAY_BUFFER, vboId1);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId1);
    
    glDrawElements(GL_TRIANGLE_FAN, 4, GL_UNSIGNED_INT, (void*)(0 * sizeof(GLuint)));

    glBindBuffer(GL_ARRAY_BUFFER, vboId2);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId2);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId2);
    
    glDrawElements(GL_TRIANGLE_FAN, 5, GL_UNSIGNED_INT, (void*)(0 * sizeof(GLuint)));
}
```

## 2. Varianta 2 - doua VAO (recomandat)
Dupa cum se poate observa in varianta anterioara, logica pentru functia de desenare
este complicata si usor de gresit. O solutie simpla pentru aceasta problema este folosirea 
a doua VAO-uri, cate unul pentru fiecare obiect.

```cpp
DreptunghiSiPentagon()
{
    // Primul VAO
    glGenVertexArrays(1, &vaoId1);
    glBindVertexArray(vaoId1);

    glGenBuffers(1, &vboId1);
    glBindBuffer(GL_ARRAY_BUFFER, vboId1);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices1), vertices1, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &colorBufferId1);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId1);
    glBufferData(GL_ARRAY_BUFFER, sizeof(colors1), colors1, GL_STATIC_DRAW);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &eboId1);														
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId1);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices1), indices1, GL_STATIC_DRAW);


    // Al doilea VAO
    glGenVertexArrays(1, &vaoId2);
    glBindVertexArray(vaoId2);

    glGenBuffers(1, &vboId2);
    glBindBuffer(GL_ARRAY_BUFFER, vboId2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices2), vertices2, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &colorBufferId2);
    glBindBuffer(GL_ARRAY_BUFFER, colorBufferId2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(colors2), colors2, GL_STATIC_DRAW);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);

    glGenBuffers(1, &eboId2);														
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboId2);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices2), indices2, GL_STATIC_DRAW);
}
```

Astfel, in functia de randare trebuie doar sa setam VAO-ul corect inainte sa desenam:
```cpp
void render() const
{
    glBindVertexArray(vaoId1);
    
    glDrawElements(GL_TRIANGLE_FAN, 4, GL_UNSIGNED_INT, (void*)(0 * sizeof(GLuint)));
    
    glBindVertexArray(vaoId2);
    
    glDrawElements(GL_TRIANGLE_FAN, 5, GL_UNSIGNED_INT, (void*)(0 * sizeof(GLuint)));
}
```

Aceasta varianta am folosit-o si pana acum in alte laboratoare, singura diferenta fiind ca 
am si utilizat clase diferite pentru obiecte diferite.